
VALID_TOOLCHAINS := pnacl newlib glibc
CONFIG ?= Debug

include $(NACL_SDK_ROOT)/tools/common.mk

LOCAL_PATH := $(call my-dir)
#FOR_LINUX :=1
NOT_ARM := 1
NO_REC := 1
NO_REND := 1


RZDCY_SRC_DIR = ../../core

include $(RZDCY_SRC_DIR)/core.mk

TARGET = reicast
DEPS = nacl_io
LIBS = ppapi_gles2 ppapi_cpp ppapi pthread nacl_io

CFLAGS  =  -Wno-error -Wno-ignored-attributes 
CFLAGS += -I$(RZDCY_SRC_DIR) -I$(RZDCY_SRC_DIR)/deps
CFLAGS += -D RELEASE -D TARGET_NO_REC -D TARGET_NACL32 -DNO_REND
CFLAGS += -D TARGET_NO_EXCEPTIONS -D TARGET_NO_NVMEM

SOURCES = $(RZDCY_FILES) ../../core/nacl/nacl.cpp

# Project Build flags
WARNINGS ?=-Wno-long-long -Wno-switch-enum
CXXFLAGS += -std=gnu++0x $(WARNINGS)


# Build rules generated by macros from common.mk:

$(foreach dep,$(DEPS),$(eval $(call DEPEND_RULE,$(dep))))

$(foreach src,$(SOURCES),$(eval $(call COMPILE_RULE,$(src),$(CFLAGS))))

# The PNaCl workflow uses both an unstripped and finalized/stripped binary.
# On NaCl, only produce a stripped binary for Release configs (not Debug).
ifneq (,$(or $(findstring pnacl,$(TOOLCHAIN)),$(findstring Release,$(CONFIG))))
$(eval $(call LINK_RULE,$(TARGET)_unstripped,$(SOURCES),$(LIBS),$(DEPS)))
$(eval $(call STRIP_RULE,$(TARGET),$(TARGET)_unstripped))
else
$(eval $(call LINK_RULE,$(TARGET),$(SOURCES),$(LIBS),$(DEPS)))
endif

SHELL = sh

$(eval $(call NMF_RULE,$(TARGET),))